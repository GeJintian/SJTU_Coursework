\documentclass[12pt,a4paper]{article}
%\usepackage{ctex}
\usepackage{amsmath,amscd,amsbsy,amssymb,latexsym,url,bm,amsthm}
\usepackage{epsfig,graphicx,subfigure}
\usepackage{enumitem,balance}
\usepackage{wrapfig}
\usepackage{mathrsfs,euscript}
\usepackage[x11names,svgnames,dvipsnames]{xcolor}
\usepackage{hyperref}
\usepackage[vlined,ruled,commentsnumbered,linesnumbered]{algorithm2e}
\usepackage{listings}
\usepackage{multicol}


\usepackage{tikz}
\usepackage{verbatim}
%\usepackage[active,tightpage]{preview}
\usepackage{preview}
\PreviewEnvironment{tikzpicture}
\usetikzlibrary{trees}

%\usepackage{fontspec}
\renewcommand{\listalgorithmcfname}{List of Algorithms}
\renewcommand{\algorithmcfname}{Alg}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{exercise}{Exercise}
\newtheorem*{solution}{Solution}
\newtheorem{definition}{Definition}
\theoremstyle{definition}


%\numberwithin{equation}{section}
%\numberwithin{figure}{section}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\newcommand{\postscript}[2]
 {\setlength{\epsfxsize}{#2\hsize}
  \centerline{\epsfbox{#1}}}

\renewcommand{\baselinestretch}{1.0}

\setlength{\oddsidemargin}{-0.365in}
\setlength{\evensidemargin}{-0.365in}
\setlength{\topmargin}{-0.3in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textheight}{10.1in}
\setlength{\textwidth}{7in}
\makeatletter \renewenvironment{proof}[1][Proof] {\par\pushQED{\qed}\normalfont\topsep6\p@\@plus6\p@\relax\trivlist\item[\hskip\labelsep\bfseries#1\@addpunct{.}]\ignorespaces}{\popQED\endtrivlist\@endpefalse} \makeatother
\makeatletter
\renewenvironment{solution}[1][Solution] {\par\pushQED{\qed}\normalfont\topsep6\p@\@plus6\p@\relax\trivlist\item[\hskip\labelsep\bfseries#1\@addpunct{.}]\ignorespaces}{\popQED\endtrivlist\@endpefalse} \makeatother


\definecolor{codegreen}{rgb}{0.44,0.68,0.28}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.96,0.96,0.96}

\lstset{
language=C++,
frame=shadowbox,
keywordstyle = \color{blue}\bfseries,
commentstyle=\color{codegreen},
tabsize = 4,
backgroundcolor=\color{backcolour},
numbers=left,
numbersep=5pt,
breaklines=true,
emph = {int,float,double,char},emphstyle=\color{orange},
emph ={[2]const, typedef},emphstyle = {[2]\color{red}} }



\begin{document}
\noindent

%========================================================================
\noindent\framebox[\linewidth]{\shortstack[c]{
\Large{\textbf{Lab07-Trees}}\vspace{1mm}\\
VE281 - Data Structures and Algorithms, Xiaofeng Gao, TA: Qingmin Liu, Autumn 2019}}
%CS26019 - Algorithm Design and Analysis, Xiaofeng Gao, Autumn 2019}}
\begin{center}
\footnotesize{\color{red}$*$ Please upload your assignment to website. Contact webmaster for any questions.}

\footnotesize{\color{blue}$*$ Name:Jintian Ge  \quad Student ID:517021911142 \quad Email: gejintian@sjtu.edu.cn}
\end{center}

{\color{blue}\textbf{Hint:} You can use the package \textbf{tikz} to draw trees.}

\begin{figure}[h]
\centering
\begin{tikzpicture}
	[thick,scale=0.8, every node/.style={scale=1.2}]
	\node {root}
	child {node {1}
		child {node {2}
			child {node {3}}
		}
		child [missing] {}
		child {node {3}
			child {node {2}}
		}
	}	
	child [missing] {}	
	child [missing] {}
	child [missing] {}	
	child [missing] {}	
	child { node {2}
		child {node {1}
			child {node {3}}
		}
		child [missing] {}
		child {node {3}
			child {node {1}}
		}
	}	
	child [missing] {}	
	child [missing] {}
	child [missing] {}	
	child [missing] {}	
	child { node {3}
		child {node {1}
			child {node {2}}
		}
		child [missing] {}
		child {node {2}
			child {node {1}}
		}
	};
	\end{tikzpicture}
	\end{figure}

\begin{enumerate}

\item	Red-black Tree
	\begin{enumerate}
		\item Suppose that we insert a sequence of keys 9, 3, 1 into an initially empty red-black tree. Draw the resulting red-black tree.
		
		\item Suppose that we further insert key 6 into the red-black tree you get in Problem (1-a). Draw the resulting red-black tree.
		
		\item Suppose that we further insert keys 2, 8 into the red-black tree you get in Problem (1-b). Draw the resulting red-black tree.
		
		\item Suppose that we further insert key 7 into the red-black tree you get in Problem (1-c). Draw the resulting red-black tree.
		
		\item Suppose that we further insert keys 4, 5 into the red-black tree you get in Problem (1-d). Draw the resulting red-black tree.
		
	\end{enumerate}
	
	When you draw the red-black tree, please indicate the color of each node in the tree.
For example, you can color each node or put a letter \textbf{b/r} near each node.

\begin{solution} 
\begin{enumerate}
    \item


\begin{tikzpicture}
	[thick,scale=0.8, every node/.style={scale=1.2}]
	\node {\textcolor{black}{3}}
	child{node {\textcolor{red}{1}}}
    child[missing]{}
	child{node{\textcolor{red}{9}}};
\end{tikzpicture}


\item


\begin{tikzpicture}
	[thick,scale=0.8, every node/.style={scale=1.2}]
	\node {\textcolor{black}{3}}
	child{node {\textcolor{black}{1}}}
    child[missing]{}
	child{node{\textcolor{black}{9}}
	    child{node{\textcolor{red}{6}}}
	    child[missing]{}
	    child[missing]{}
	};
\end{tikzpicture}


    \item


\begin{tikzpicture}
	[thick,scale=0.8, every node/.style={scale=1.2}]
	\node {\textcolor{black}{3}}
	child{node {\textcolor{black}{1}}
	    child[missing]{}
	    child[missing]{}
	    child{node{\textcolor{red}{2}}}
	}
    child[missing]{}
    child[missing]{}
    child[missing]{}
	child{node{\textcolor{black}{8}}
	    child{node{\textcolor{red}{6}}}
	    child[missing]{}
	    child{node{\textcolor{red}{9}}}
	};
\end{tikzpicture}


    \item


\begin{tikzpicture}
	[thick,scale=0.8, every node/.style={scale=1.2}]
	\node {\textcolor{black}{3}}
	child{node {\textcolor{black}{1}}
	    child[missing]{}
	    child[missing]{}
	    child{node{\textcolor{red}{2}}}
	}
    child[missing]{}
    child[missing]{}
    child[missing]{}
	child{node{\textcolor{red}{8}}
	    child{node{\textcolor{black}{6}}
	        child[missing]{}
	        child{node{\textcolor{red}{7}}}
	        }
	    child[missing]{}
	    child{node{\textcolor{black}{9}}}
	};
\end{tikzpicture}


    \item

\begin{tikzpicture}
	[thick,scale=0.8, every node/.style={scale=1.2}]
	\node {\textcolor{black}{6}}
	child{node {\textcolor{red}{3}}
	    child{node{\textcolor{black}{1}}
	        child[missing]{}
	        child{node{\textcolor{red}{2}}}
	        }
	    child[missing]{}
	    child{node{\textcolor{black}{4}}
	        child[missing]{}
	        child{node{\textcolor{red}{5}}}
	    }
	}
    child[missing]{}
    child[missing]{}
    child[missing]{}
	child{node{\textcolor{red}{8}}
	    child{node{\textcolor{black}{7}}}
	    child{node{\textcolor{black}{9}}}
	};
\end{tikzpicture}

\end{enumerate}
\end{solution}

\item  Show the alphabet trie for the following collection of words: \{chicken, goose, deer, horse, antelope, anteater, goldfish, ant, goat, duck\}.

\begin{solution} 
In this tree, I use $(*)$ to indicate the alphabet in the path.


\begin{tikzpicture}
	[thick,scale=0.8, every node/.style={scale=1.2}]
	\node {root}
	child{node {chicken,(c)}}
	child[missing]{}
    child{node{,(g)}
        child{node{,(o)}
            child{node{goose,(o)}}
            child[missing]{}
            child{node{goldfish,(l)}}
            child[missing]{}
            child{node{goat,(a)}}
        }
    }
    child[missing]{}
    child{node{,(d)}
        child{node{deer,(e)}}
        child[missing]{}
        child{node{duck,(u)}}
    }
    child[missing]{}
    child{node{horse,(h)}}
    child[missing]{}
	child{node{,(a)}
	    child{node{,(n)}
	        child{node{,(t)}
	            child{node{ant,(\$)}}
	            child{node{,(e)}
	                child{node{antelope,(l)}}
	                child[missing]{}
	                child{node{anteater,(a)}}
	            }
	        }
	    }
	};
\end{tikzpicture}
\end{solution}

\item  Show that any arbitrary n-node binary search tree can be transformed into any other arbitrary n-node binary search tree using $O(n)$ rotations. 

	{\color{blue} Hint: First show that at most $n-1$ right rotations suffice to transform the tree into a right-skewed binary
search tree.}

\begin{solution} 
First we show that at most $n-1$ right rotations suffice to transform the tree into a right-skewed binary search tree:

From the most right node, we begin to search upwards. For any nodes with a left subtree, we apply right rotation. In a right rotation, it will rotate one node into the right most path. So, at most $n-1$ rotations can ensure that the BST becomes a right-skewed BST.

Now, for any trees with the same nodes, they will have the same right-skewed BST convertion. Suppose we have two trees A and B. We convert both A and B into a right-skewed tree, and remember the process of B, and finally convert the right-skewed tree which is converted by A into B.
\end{solution}

\item  Suppose that an AVL tree insertion breaks the AVL balance condition. Suppose node $P$ is the first node that has a balance condition violation in the insertion access path from the leaf. Assume the key is inserted into the left subtree of $P$ and the left child of $P$ is node $A$. Prove the following claims:
	\begin{enumerate}
		\item  Before insertion, the balance factor of node $P$ is 1. After insertion and before applying rotation to ﬁx the violation, the balance factor of node $P$ is 2.
		\item Before insertion, the balance factor of node $A$ is 0. After insertion and before applying rotation to ﬁx the violation, the balance factor of node $A$ cannot be 0.
	\end{enumerate}
	
\begin{solution} 

Notation: 

$'$ denotes the tree after insertion. For example, $A'$ denotes tree A after insertion.

$H(*)$ denotes height of the tree *.
\begin{enumerate}
    \item 
    We use B to denote the right child of P. B could be null. Then, before insertion, P is balanced. So we have 
    $$|H(A)-H(B)|\leq 1 \Rightarrow |B(P)|\leq 1$$
    Since each insertion will increase the height of a tree by at most 1, we have $$H(A')\leq H(A)+1,$$$$B(P')\leq B(P)+1$$
    So, $-1\leq B(P')\leq 2$. After insertion, P is unbalanced, so we have: $$B(P')=2$$ $$B(P)=1$$
    
    \item $P'$ is unbalanced means $H(A)$ increases after insertion. This indicates that the subtree of A with greater height has increased.
    
    We assume that $H(A.left)\geq H(A.right)$. Then, H(A.left) will be increased by one, such that:
    $$B(A')=H(A.left')-H(A.right)=H(A.left)+1-H(A.right) \neq 0$$
    Since after insertion, $A'$ is still balanced, $|B(A')|\leq 1$. This can be converted to:
    $$H(A.left)+1-H(A.right)\leq 1$$
    In the beginning we assume that $H(A.left)\geq H(A.right)$. So finally we have:
    $$H(A.left)-H(A.right)=0\Rightarrow B(A)=0$$
    
\end{enumerate}
\end{solution}

\end{enumerate}

%========================================================================
\end{document}